{
  "language": "Solidity",
  "sources": {
    "contracts/HashBox.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport './HashBoxFactory.sol';\n\n/**\n * @title Hash Box\n * @dev Store contacts and make transfers\n */\ncontract HashBox {\n  uint256 private _ipfsCount = 0;\n  uint256 private _totalContacts;\n  uint256 private _securityTimelock;\n  uint256 private _lastTimelockUpdate;\n  HashBoxFactory private _factory;\n  string public boxName;\n\n  struct Contact {\n    string name;\n    address wallet;\n    uint256 dateAdded;\n  }\n\n  struct user {\n    string name;\n    Contact[] contactList;\n    cid[] cidList;\n  }\n\n  struct cid {\n    string _ipfsHash;\n    string _title;\n  }\n\n  struct Ipfs {\n    uint id;\n    string hash;\n    string title;\n    address author;\n  }\n\n  event IpfsPinned(uint id, string hash, string title, address author);\n\n  // Array of Contact structs (contacts in address box)\n  Contact[] private contacts;\n  // Mapping to retrieve Array index from address or name\n  mapping(address => uint256) private addressToIndex;\n  mapping(string => uint256) private nameToIndex;\n  mapping(uint => Ipfs) public _ipfs;\n  mapping(address => user) userList;\n\n  // Hash of the contract owner => TODO: does this need to be public?\n  address public owner;\n\n  constructor(address _boxOwner, string memory _boxName) {\n    owner = _boxOwner;\n    boxName = _boxName;\n    _ipfsCount = 0;\n    _totalContacts = 0;\n    _securityTimelock = 90; // in seconds\n    _lastTimelockUpdate = block.timestamp;\n    _factory = HashBoxFactory(msg.sender);\n  }\n\n  // MODIFIERS\n\n  // Only the owner of the contract may call\n  modifier onlyOwner() {\n    require(msg.sender == owner, 'Only the contract owner may call this function');\n    _;\n  }\n\n  // Only permitted after x time (z.B. new contacts can't be paid for at least this amount of time)\n  modifier timelockElapsed() {\n    require(block.timestamp >= _lastTimelockUpdate + _securityTimelock, 'You must wait for the security timelock to elapse before this is permitted');\n    _;\n  }\n\n  // ipfs management\n\n  // save content identifier to public contract\n  function pinHash(string memory _ipfsHash, string memory _title) public onlyOwner {\n    require(bytes(_ipfsHash).length > 0);\n    require(bytes(_title).length > 0);\n    require(msg.sender != address(0));\n    _ipfsCount++;\n    _ipfs[_ipfsCount] = Ipfs(_ipfsCount, _ipfsHash, _title, msg.sender);\n    _pinHash(msg.sender, _ipfsHash, _title);\n    // Trigger an event\n    emit IpfsPinned(_ipfsCount, _ipfsHash, _title, msg.sender);\n  }\n\n  // hash the hash helper function\n  function _pinHash(address me, string memory _ipfsHash, string memory _title) internal {\n    cid memory newCid = cid(_ipfsHash, _title);\n    userList[me].cidList.push(newCid);\n  }\n\n  // fetch users uploaded cids\n  function getMyCidList() external view returns (cid[] memory) {\n    return userList[msg.sender].cidList;\n  }\n\n  // CONTACT MANAGEMENT\n\n  // add a user / Contact struct to the contacts Array\n  function addContact(string calldata _name, address _address) public onlyOwner {\n    Contact memory person = Contact(_name, _address, block.timestamp);\n    contacts.push(person);\n    addressToIndex[_address] = _totalContacts;\n    nameToIndex[_name] = _totalContacts;\n    _totalContacts++;\n  }\n\n  // find and remove a contact via their name\n  function removeContactByName(string calldata name) public onlyOwner {\n    uint256 removeIndex = nameToIndex[name];\n    require(removeIndex < _totalContacts, 'Index is out of range');\n    contacts[removeIndex] = contacts[contacts.length - 1];\n    nameToIndex[contacts[contacts.length - 1].name] = removeIndex;\n    delete nameToIndex[name];\n    contacts.pop();\n    _totalContacts--;\n  }\n\n  // Get all contact data for this HashBox\n  function readAllContacts() public view onlyOwner returns (Contact[] memory) {\n    Contact[] memory result = new Contact[](_totalContacts);\n    for (uint256 i = 0; i < _totalContacts; i++) {\n      result[i] = contacts[i];\n    }\n    return result;\n  }\n\n  function readTotalContacts() public view onlyOwner returns (uint256 totalContacts) {\n    totalContacts = _totalContacts;\n    return totalContacts;\n  }\n\n  function readSecurityTimelock() public view onlyOwner returns (uint256 securityTimelock) {\n    securityTimelock = _securityTimelock;\n    return securityTimelock;\n  }\n\n  function readLastTimelockUpdate() public view onlyOwner returns (uint256 lastTimelockUpdate) {\n    lastTimelockUpdate = _lastTimelockUpdate;\n    return lastTimelockUpdate;\n  }\n\n  // UPDATE VARIABLE FUNCTIONS\n\n  // Update this user's personal timelock\n  function updateTimelock(uint256 duration) public onlyOwner timelockElapsed {\n    _securityTimelock = duration;\n    _lastTimelockUpdate = block.timestamp;\n  }\n\n  // PAYMENT FUNCTIONS\n\n  // Get the latest TX cost from the Factory\n  function checkTxCost() public view returns (uint256 _price) {\n    _price = _factory.txCost();\n    return _price;\n  }\n\n  // Transfer ETH to a contact\n  function payContactByName(string calldata name, uint256 sendValue) public payable onlyOwner {\n    Contact memory recipient = contacts[nameToIndex[name]];\n    require(block.timestamp >= recipient.dateAdded + _securityTimelock, 'This contact was added too recently');\n    require(msg.value >= _factory.txCost() + sendValue, 'Not enough ETH!');\n    (bool sent, ) = recipient.wallet.call{ value: sendValue }('');\n    require(sent, 'Failed to send Ether');\n  }\n\n  // Leaving these two functions in in case of accidental transfer of money into contract\n  function checkBalance() public view onlyOwner returns (uint256 amount) {\n    amount = address(this).balance;\n    return amount;\n  }\n\n  function withdraw() public onlyOwner {\n    uint256 amount = checkBalance();\n    (bool sent, ) = msg.sender.call{ value: amount }('');\n    require(sent, 'There was a problem while withdrawing');\n  }\n}\n"
    },
    "contracts/HashBoxFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport './HashBox.sol';\n\n/**\n * @title Hash Box Factory\n * @dev Create an address book to store contacts and make transfers\n */\ncontract HashBoxFactory {\n  uint256 public newBoxCost;\n  uint256 public newPinCost;\n  uint256 public txCost;\n  address public owner;\n  uint public ipfsCount = 0;\n  uint public boxCount = 0;\n  mapping(uint => Ipfs) public _ipfs;\n  string public contractName = 'The Buny Project: HashBox Factory';\n  mapping(address => HashBox) private hashBoxes;\n  mapping(address => user) userList;\n  mapping(address => box) boxList;\n\n  // list of users\n  struct user {\n    string name;\n    cid[] cidList;\n    box[] boxList;\n  }\n\n  struct cid {\n    string _ipfsHash;\n    string _title;\n  }\n\n  struct box {\n    string _boxName;\n    address contractAddress;\n  }\n\n  struct Ipfs {\n    uint id;\n    string hash;\n    string title;\n    address author;\n  }\n  // event: ipfs cid/hash added\n  event IpfsPinned(uint id, string hash, string title, address author);\n  // event: new\n  event HashBoxCreated(uint boxCount, string _boxName, address owner, address contractAddress);\n\n  constructor() {\n    owner = msg.sender;\n    newBoxCost = 0.02 ether; // in avax\n    txCost = 0.001 ether; // in avax\n    newPinCost = 0.005 ether;\n  }\n\n  // MODIFIERS\n\n  // Only the owner of the contract may call\n  modifier onlyOwner() {\n    require(msg.sender == owner, 'Only the contract owner may call this function');\n    _;\n  }\n\n  // Register username to wallet address\n\n  function createAccount(string calldata name) external {\n    require(checkUserExists(msg.sender) == false, 'User already exists!');\n    require(bytes(name).length > 0, 'Username cannot be empty!');\n    userList[msg.sender].name = name;\n  }\n\n  // Returns the default name provided by an user\n  function getUsername(address pubkey) external view returns (string memory) {\n    require(checkUserExists(pubkey), 'User is not registered!');\n    return userList[pubkey].name;\n  }\n\n  // check if username already exist\n  function checkUserExists(address pubkey) public view returns (bool) {\n    return bytes(userList[pubkey].name).length > 0;\n  }\n\n  // save content identifier to public contract\n  function pinHash(string memory _ipfsHash, string memory _title) public payable {\n    require(checkUserExists(msg.sender), 'Create an account first!');\n    require(msg.value >= newPinCost, 'Not enough AVAX');\n    require(bytes(_ipfsHash).length > 0);\n    require(bytes(_title).length > 0);\n    require(msg.sender != address(0));\n    ipfsCount++;\n    _ipfs[ipfsCount] = Ipfs(ipfsCount, _ipfsHash, _title, msg.sender);\n    _pinHash(msg.sender, _ipfsHash, _title);\n    // Trigger an event\n    emit IpfsPinned(ipfsCount, _ipfsHash, _title, msg.sender);\n  }\n\n  // Create a new HashBox struct for this user\n  function createHashBox(string memory _boxName) public payable returns (address contractAddress) {\n    require(checkUserExists(msg.sender), 'Register username first!');\n    require(msg.value >= newBoxCost, 'Not enough AVAX');\n    boxCount++;\n    HashBox newBox = new HashBox(msg.sender, _boxName);\n    hashBoxes[msg.sender] = newBox;\n    contractAddress = address(newBox);\n    _createHashBox(msg.sender, _boxName, contractAddress);\n    emit HashBoxCreated(boxCount, _boxName, msg.sender, contractAddress);\n    return contractAddress;\n  }\n\n  // hash the hash helper function\n  function _pinHash(address me, string memory _ipfsHash, string memory _title) internal {\n    cid memory newCid = cid(_ipfsHash, _title);\n    userList[me].cidList.push(newCid);\n  }\n\n  function _createHashBox(address me, string memory _boxName, address contractAddress) internal {\n    box memory newBox = box(_boxName, contractAddress);\n    userList[me].boxList.push(newBox);\n  }\n\n  function getMyBoxList() external view returns (box[] memory) {\n    require(checkUserExists(msg.sender), 'Register a username first');\n    return userList[msg.sender].boxList;\n  }\n\n  // fetch users uploaded cids\n  function getMyCidList() external view returns (cid[] memory) {\n    require(checkUserExists(msg.sender), 'Create an account first!');\n    return userList[msg.sender].cidList;\n  }\n\n  // Return this user's Hash Box contract address\n  function fetchHashBox() public view returns (HashBox userData) {\n    userData = hashBoxes[msg.sender];\n    return userData;\n  }\n\n  function updatePinCost(uint256 _pinCost) public onlyOwner {\n    newPinCost = _pinCost;\n  }\n\n  // Update the price to open an account here\n  function updateBoxCost(uint256 _accountOpenCost) public onlyOwner {\n    newBoxCost = _accountOpenCost;\n  }\n\n  // Update the price to interact with this contract\n  function updateTransactionCost(uint256 _txCost) public onlyOwner {\n    txCost = _txCost;\n  }\n\n  // PAYMENT FUNCTIONS\n  function checkBalance() public view onlyOwner returns (uint256 amount) {\n    amount = address(this).balance;\n    return amount;\n  }\n\n  // Withdraw contract balance\n  function withdraw() public onlyOwner {\n    (bool sent, ) = msg.sender.call{ value: checkBalance() }('');\n    require(sent, 'There was a problem while withdrawing');\n  }\n}\n"
    },
    "contracts/HashBoxBeta.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport './HashBoxFactory.sol';\n\n/**\n * @title Hash Box Beta\n * @dev Store contacts and make transfers\n */\ncontract HashBoxBeta {\n  uint256 private _ipfsCount;\n  uint256 private _totalContacts;\n  uint256 private _securityTimelock;\n  uint256 private _lastTimelockUpdate;\n  HashBoxFactory private _factory;\n  uint public ipfsCount = 0;\n  string public boxName;\n\n  struct Contact {\n    string name;\n    address wallet;\n    uint256 dateAdded;\n  }\n\n  struct box {\n    string BoxName;\n    cid[] cidList;\n  }\n\n  struct cid {\n    string _ipfsHash;\n    string _title;\n  }\n\n  struct Ipfs {\n    uint id;\n    string hash;\n    string title;\n    address author;\n  }\n\n  event IpfsUploaded(uint id, string hash, string title, address author);\n\n  // Array of Contact structs (contacts in address book)\n  Contact[] private contacts;\n\n  // Mapping to retrieve Array index from address or name\n  mapping(address => uint256) private addressToIndex;\n  mapping(string => uint256) private nameToIndex;\n  mapping(uint => Ipfs) public _ipfs;\n  mapping(address => box) boxList;\n\n  // Address of the contract owner => TODO: does this need to be public?\n  address public owner;\n\n  constructor(address _boxOwner, string memory _boxName) {\n    owner = _boxOwner;\n    boxName = _boxName;\n    _ipfsCount = 0;\n    _totalContacts = 0;\n    _securityTimelock = 90; // in seconds\n    _lastTimelockUpdate = block.timestamp;\n    _factory = HashBoxFactory(msg.sender);\n  }\n\n  // MODIFIERS\n\n  // Only the owner of the contract may call\n  modifier onlyOwner() {\n    require(msg.sender == owner, 'Only the contract owner may call this function');\n    _;\n  }\n\n  // Only permitted after x time (z.B. new contacts can't be paid for at least this amount of time)\n  modifier timelockElapsed() {\n    require(block.timestamp >= _lastTimelockUpdate + _securityTimelock, 'You must wait for the security timelock to elapse before this is permitted');\n    _;\n  }\n\n  // Hash Box Functions\n\n  function uploadIpfs(string memory _ipfsHash, string memory _title) public {\n    require(bytes(_ipfsHash).length > 0);\n    require(bytes(_title).length > 0);\n    require(msg.sender != address(0));\n    ipfsCount++;\n    _ipfs[ipfsCount] = Ipfs(ipfsCount, _ipfsHash, _title, msg.sender);\n    _uploadIpfs(msg.sender, _ipfsHash, _title);\n    // Trigger =upload event\n    emit IpfsUploaded(ipfsCount, _ipfsHash, _title, msg.sender);\n  }\n\n  // upload helper function\n\n  function _uploadIpfs(address me, string memory _ipfsHash, string memory _title) internal {\n    cid memory newCid = cid(_ipfsHash, _title);\n    boxList[me].cidList.push(newCid);\n  }\n\n  // fetch cid list array\n  function getMyCidList() external view returns (cid[] memory) {\n    return boxList[msg.sender].cidList;\n  }\n\n  // CONTACT MANAGEMENT\n\n  function addContact(string calldata _name, address _address) public onlyOwner {\n    Contact memory person = Contact(_name, _address, block.timestamp);\n    contacts.push(person);\n    addressToIndex[_address] = _totalContacts;\n    nameToIndex[_name] = _totalContacts;\n    _totalContacts++;\n  }\n\n  // find and remove a contact via their name\n  function removeContactByName(string calldata name) public onlyOwner {\n    uint256 removeIndex = nameToIndex[name];\n    require(removeIndex < _totalContacts, 'Index is out of range');\n    contacts[removeIndex] = contacts[contacts.length - 1];\n    nameToIndex[contacts[contacts.length - 1].name] = removeIndex;\n    delete nameToIndex[name];\n    contacts.pop();\n    _totalContacts--;\n  }\n\n  // Get all contact data for this AddressBook\n  function readAllContacts() public view onlyOwner returns (Contact[] memory) {\n    Contact[] memory result = new Contact[](_totalContacts);\n    for (uint256 i = 0; i < _totalContacts; i++) {\n      result[i] = contacts[i];\n    }\n    return result;\n  }\n\n  function readTotalContacts() public view onlyOwner returns (uint256 totalContacts) {\n    totalContacts = _totalContacts;\n    return totalContacts;\n  }\n\n  function readSecurityTimelock() public view onlyOwner returns (uint256 securityTimelock) {\n    securityTimelock = _securityTimelock;\n    return securityTimelock;\n  }\n\n  function readLastTimelockUpdate() public view onlyOwner returns (uint256 lastTimelockUpdate) {\n    lastTimelockUpdate = _lastTimelockUpdate;\n    return lastTimelockUpdate;\n  }\n\n  // UPDATE VARIABLE FUNCTIONS\n\n  // Update this user's personal timelock\n  function updateTimelock(uint256 duration) public onlyOwner timelockElapsed {\n    _securityTimelock = duration;\n    _lastTimelockUpdate = block.timestamp;\n  }\n\n  // Transfer ETH to a contact\n  // Transfer ETH to a contact\n  function payContactByName(string calldata name, uint256 sendValue) public payable onlyOwner {\n    Contact memory recipient = contacts[nameToIndex[name]];\n    require(block.timestamp >= recipient.dateAdded + _securityTimelock, 'This contact was added too recently');\n    (bool sent, ) = recipient.wallet.call{ value: sendValue }('');\n    require(sent, 'Failed to send Ether');\n  }\n\n  // Leaving these two functions in in case of accidental transfer of money into contract\n  function checkBalance() public view onlyOwner returns (uint256 amount) {\n    amount = address(this).balance;\n    return amount;\n  }\n\n  function withdraw() public onlyOwner {\n    uint256 amount = checkBalance();\n    (bool sent, ) = msg.sender.call{ value: amount }('');\n    require(sent, 'There was a problem while withdrawing');\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
