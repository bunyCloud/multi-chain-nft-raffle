{
  "language": "Solidity",
  "sources": {
    "contracts/CollectionPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport \"./CollectionPoolFactory.sol\";\r\n\r\n/**\r\n * @title Address Pool\r\n * @dev Store collections and make transfers\r\n */\r\ncontract CollectionPool {\r\n    uint256 private _totalCollections;\r\n    uint256 private _securityTimelock;\r\n    uint256 private _lastTimelockUpdate;\r\n    CollectionPoolFactory private _factory;\r\n\r\n    struct Collection {\r\n        string name;\r\n        string symbol;\r\n        address wallet;\r\n        uint256 dateAdded;\r\n    }\r\n\r\n    // Array of Collection structs (collections in address pool)\r\n    Collection[] private collections;\r\n\r\n    // Mapping to retrieve Array index from address or name\r\n    mapping(address => uint256) private addressToIndex;\r\n    mapping(string => uint256) private nameToIndex;\r\n    mapping(string => uint256) private symbolToIndex;\r\n    address public owner;\r\n\r\n    event collectionAdded(\r\n        string _name,\r\n        string _symbol,\r\n        address _address\r\n    );\r\n\r\n    constructor(address _poolOwner) {\r\n        owner = _poolOwner;\r\n        _totalCollections = 0;\r\n        _securityTimelock = 90; // in seconds\r\n        _lastTimelockUpdate = block.timestamp;\r\n        _factory = CollectionPoolFactory(msg.sender);\r\n    }\r\n\r\n    // MODIFIERS\r\n\r\n    // Only the owner of the contract may call\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only the contract owner may call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // Only permitted after x time (z.B. new collections can't be paid for at least this amount of time)\r\n    modifier timelockElapsed() {\r\n        require(\r\n            block.timestamp >= _lastTimelockUpdate + _securityTimelock,\r\n            \"You must wait for the security timelock to elapse before this is permitted\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // CONTACT MANAGEMENT\r\n\r\n    // add a user / Collection struct to the collections Array\r\n    function addCollection(string calldata _name, string memory _symbol, address _address)\r\n        public\r\n        onlyOwner\r\n    {\r\n        Collection memory person = Collection(_name, _symbol,  _address, block.timestamp);\r\n        collections.push(person);\r\n        addressToIndex[_address] = _totalCollections;\r\n        nameToIndex[_name] = _totalCollections;\r\n        symbolToIndex[_symbol] = _totalCollections;\r\n        _totalCollections++;\r\n        emit collectionAdded(_name, _symbol, _address);\r\n    \r\n    }\r\n\r\n   \r\n\r\n    // Get all contact data for this CollectionPool\r\n    function readAllCollections()\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (Collection[] memory)\r\n    {\r\n        Collection[] memory result = new Collection[](_totalCollections);\r\n        for (uint256 i = 0; i < _totalCollections; i++) {\r\n            result[i] = collections[i];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function readTotalCollections()\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (uint256 totalCollections)\r\n    {\r\n        totalCollections = _totalCollections;\r\n        return totalCollections;\r\n    }\r\n\r\n    function readSecurityTimelock()\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (uint256 securityTimelock)\r\n    {\r\n        securityTimelock = _securityTimelock;\r\n        return securityTimelock;\r\n    }\r\n\r\n    function readLastTimelockUpdate()\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (uint256 lastTimelockUpdate)\r\n    {\r\n        lastTimelockUpdate = _lastTimelockUpdate;\r\n        return lastTimelockUpdate;\r\n    }\r\n\r\n    // UPDATE VARIABLE FUNCTIONS\r\n\r\n    // Update this user's personal timelock\r\n    function updateTimelock(uint256 duration) public onlyOwner timelockElapsed {\r\n        _securityTimelock = duration;\r\n        _lastTimelockUpdate = block.timestamp;\r\n    }\r\n\r\n    // PAYMENT FUNCTIONS\r\n\r\n    // Get the latest TX cost from the Factory\r\n    function checkTxCost() public view returns (uint256 _price) {\r\n        _price = _factory.txCost();\r\n        return _price;\r\n    }\r\n\r\n  \r\n\r\n    // Leaving these two functions in in case of accidental transfer of money into contract\r\n    function checkBalance() public view onlyOwner returns (uint256 amount) {\r\n        amount = address(this).balance;\r\n        return amount;\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        uint256 amount = checkBalance();\r\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\r\n        require(sent, \"There was a problem while withdrawing\");\r\n    }\r\n}"
    },
    "contracts/CollectionPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport \"./CollectionPool.sol\";\r\n\r\n\r\ncontract CollectionPoolFactory {\r\n    uint256 public accountOpenCost;\r\n    uint256 public txCost;\r\n    address public owner;\r\n\r\n    mapping(address => CollectionPool) private collectionPools;\r\n    \r\n    event CollectionAdded(\r\n        address contractAddress\r\n    );\r\n\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        accountOpenCost = 0.2 ether; // in ETH\r\n        txCost = 0.001 ether; // in ETH\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only the contract owner may call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // COLLECTION POOL MANAGEMENT\r\n\r\n    // Return this user's COLLECTION POOL contract address\r\n    function fetchCollectionPool() public view returns (CollectionPool userData) {\r\n        userData = collectionPools[msg.sender];\r\n        return userData;\r\n    }\r\n\r\n    // Create a new CollectionPool struct for this user\r\n    function createCollectionPool()\r\n        public\r\n        payable\r\n        returns (address contractAddress)\r\n    {\r\n        require(msg.value >= accountOpenCost, \"Not enough ETH\");\r\n        CollectionPool newPool = new CollectionPool(msg.sender);\r\n        collectionPools[msg.sender] = newPool;\r\n        contractAddress = address(newPool);\r\n                emit CollectionAdded(contractAddress);\r\n\r\n        return contractAddress;\r\n    }\r\n\r\n    // UPDATE VARIABLE FUNCTIONS\r\n\r\n    // Update the price to open an account here\r\n    function updateAccountOpenCost(uint256 _accountOpenCost) public onlyOwner {\r\n        accountOpenCost = _accountOpenCost;\r\n    }\r\n\r\n    // Update the price to interact with this contract\r\n    function updateTransactionCost(uint256 _txCost) public onlyOwner {\r\n        txCost = _txCost;\r\n    }\r\n\r\n    // PAYMENT FUNCTIONS\r\n\r\n    function checkBalance() public view onlyOwner returns (uint256 amount) {\r\n        amount = address(this).balance;\r\n        return amount;\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        (bool sent, ) = msg.sender.call{value: checkBalance()}(\"\");\r\n        require(sent, \"There was a problem while withdrawing\");\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
