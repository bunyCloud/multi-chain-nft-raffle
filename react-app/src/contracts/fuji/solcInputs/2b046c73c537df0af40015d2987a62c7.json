{
  "language": "Solidity",
  "sources": {
    "contracts/HashBoxBeta.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport \"./HashBoxFactory.sol\";\r\n\r\n/**\r\n * @title Hash Box Beta\r\n * @dev Store contacts and make transfers\r\n */\r\ncontract HashBoxBeta {\r\n    uint256 private _ipfsCount;\r\n    uint256 private _totalContacts;\r\n    uint256 private _securityTimelock;\r\n    uint256 private _lastTimelockUpdate;\r\n    HashBoxFactory private _factory;\r\n    uint public ipfsCount = 0;\r\n    string public boxName;\r\n    \r\n    struct Contact {\r\n        string name;\r\n        address wallet;\r\n        uint256 dateAdded;\r\n    }\r\n\r\n     struct box {\r\n        string BoxName;\r\n        cid[] cidList;\r\n    }\r\n\r\n\r\n    struct cid {\r\n       string  _ipfsHash;\r\n       string  _title;\r\n    }\r\n    \r\n    \r\n    struct Ipfs {\r\n        uint id;\r\n        string hash;\r\n        string title;\r\n        address author;\r\n                }\r\n\r\n    event IpfsUploaded(\r\n    uint id,\r\n    string hash,\r\n    string title,\r\n    address author\r\n                     );\r\n\r\n\r\n    // Array of Contact structs (contacts in address book)\r\n    Contact[] private contacts;\r\n\r\n    // Mapping to retrieve Array index from address or name\r\n    mapping(address => uint256) private addressToIndex;\r\n    mapping(string => uint256) private nameToIndex;\r\n    mapping(uint => Ipfs) public _ipfs;\r\n    mapping(address => box) boxList;\r\n\r\n\r\n    // Address of the contract owner => TODO: does this need to be public?\r\n    address public owner;\r\n\r\n    constructor(address _boxOwner, string memory _boxName) {\r\n        owner = _boxOwner;\r\n        boxName = _boxName;\r\n        _ipfsCount = 0;\r\n        _totalContacts = 0;\r\n        _securityTimelock = 90; // in seconds\r\n        _lastTimelockUpdate = block.timestamp;\r\n        _factory = HashBoxFactory(msg.sender);\r\n    }\r\n\r\n    // MODIFIERS\r\n\r\n    // Only the owner of the contract may call\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only the contract owner may call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    // Only permitted after x time (z.B. new contacts can't be paid for at least this amount of time)\r\n    modifier timelockElapsed() {\r\n        require(\r\n            block.timestamp >= _lastTimelockUpdate + _securityTimelock,\r\n            \"You must wait for the security timelock to elapse before this is permitted\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // Hash Box Functions\r\n    \r\n     function uploadIpfs(string memory _ipfsHash, string memory _title) public {\r\n     require(bytes(_ipfsHash).length > 0);\r\n     require(bytes(_title).length > 0);\r\n        require(msg.sender!=address(0));\r\n        ipfsCount ++;\r\n        _ipfs[ipfsCount] = Ipfs(ipfsCount, _ipfsHash, _title, msg.sender);\r\n        _uploadIpfs(msg.sender, _ipfsHash, _title);\r\n    // Trigger =upload event\r\n        emit IpfsUploaded(ipfsCount, _ipfsHash, _title, msg.sender);\r\n                  }\r\n\r\n\r\n        // upload helper function\r\n        \r\n\r\n    function _uploadIpfs(address me,string memory _ipfsHash, string memory _title) internal {\r\n        cid memory newCid = cid(_ipfsHash, _title);\r\n        boxList[me].cidList.push(newCid);\r\n                                                                                                }\r\n\r\n\r\n        // fetch cid list array\r\n    function getMyCidList() external view returns(cid[] memory) {\r\n        return boxList[msg.sender].cidList;\r\n                                                                    }\r\n\r\n\r\n\r\n\r\n    // CONTACT MANAGEMENT\r\n\r\n     function addContact(string calldata _name, address _address)\r\n        public\r\n        onlyOwner\r\n    {\r\n        Contact memory person = Contact(_name, _address, block.timestamp);\r\n        contacts.push(person);\r\n        addressToIndex[_address] = _totalContacts;\r\n        nameToIndex[_name] = _totalContacts;\r\n        _totalContacts++;\r\n    }\r\n\r\n   // find and remove a contact via their name\r\n    function removeContactByName(string calldata name) public onlyOwner {\r\n        uint256 removeIndex = nameToIndex[name];\r\n        require(removeIndex < _totalContacts, \"Index is out of range\");\r\n        contacts[removeIndex] = contacts[contacts.length - 1];\r\n        nameToIndex[contacts[contacts.length - 1].name] = removeIndex;\r\n        delete nameToIndex[name];\r\n        contacts.pop();\r\n        _totalContacts--;\r\n    }\r\n\r\n     // Get all contact data for this AddressBook\r\n    function readAllContacts()\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (Contact[] memory)\r\n    {\r\n        Contact[] memory result = new Contact[](_totalContacts);\r\n        for (uint256 i = 0; i < _totalContacts; i++) {\r\n            result[i] = contacts[i];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function readTotalContacts()\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (uint256 totalContacts)\r\n    {\r\n        totalContacts = _totalContacts;\r\n        return totalContacts;\r\n    }\r\n\r\n \r\n\r\n    function readSecurityTimelock()\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (uint256 securityTimelock)\r\n    {\r\n        securityTimelock = _securityTimelock;\r\n        return securityTimelock;\r\n    }\r\n\r\n    function readLastTimelockUpdate()\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (uint256 lastTimelockUpdate)\r\n    {\r\n        lastTimelockUpdate = _lastTimelockUpdate;\r\n        return lastTimelockUpdate;\r\n    }\r\n\r\n    // UPDATE VARIABLE FUNCTIONS\r\n\r\n    // Update this user's personal timelock\r\n    function updateTimelock(uint256 duration) public onlyOwner timelockElapsed {\r\n        _securityTimelock = duration;\r\n        _lastTimelockUpdate = block.timestamp;\r\n    }\r\n\r\n   \r\n    // Transfer ETH to a contact\r\n    // Transfer ETH to a contact\r\n    function payContactByName(string calldata name, uint256 sendValue)\r\n        public\r\n        payable\r\n        onlyOwner\r\n    {\r\n        Contact memory recipient = contacts[nameToIndex[name]];\r\n        require(\r\n            block.timestamp >= recipient.dateAdded + _securityTimelock,\r\n            \"This contact was added too recently\"\r\n        );\r\n        (bool sent, ) = recipient.wallet.call{value: sendValue}(\"\");\r\n        require(sent, \"Failed to send Ether\");\r\n    }\r\n\r\n    // Leaving these two functions in in case of accidental transfer of money into contract\r\n    function checkBalance() public view onlyOwner returns (uint256 amount) {\r\n        amount = address(this).balance;\r\n        return amount;\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        uint256 amount = checkBalance();\r\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\r\n        require(sent, \"There was a problem while withdrawing\");\r\n    }\r\n}"
    },
    "contracts/HashBoxFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport \"./HashBoxBeta.sol\";\r\n\r\ncontract HashBoxFactory {\r\n\r\n    \r\n\r\n    uint public ipfsCount = 0;\r\n    mapping(uint => Ipfs) public _ipfs;\r\n    string public contractName = \"The Buny Project: HashBox Factory\";\r\n    address public owner;\r\n\r\n    struct user {\r\n        string name;\r\n        cid[] cidList;\r\n    }\r\n\r\n\r\n    struct cid {\r\n       string  _ipfsHash;\r\n       string  _title;\r\n    }\r\n\r\n\r\n    mapping(address => HashBoxBeta) private cidBox;\r\n    mapping(address => user) userList;\r\n\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n      \r\n    }\r\n\r\n    // MODIFIERS\r\n\r\n    // Only the owner of the contract may call\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only the contract owner may call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n\r\n    event HashBoxCreated (\r\n            string  _boxName,\r\n            address owner,\r\n            address contractAddress\r\n        );\r\n\r\n        \r\n   \r\n\r\n    struct Ipfs {\r\n    uint id;\r\n    string hash;\r\n    string title;\r\n    address author;\r\n  }\r\n\r\n\r\n    event IpfsUploaded(\r\n    uint id,\r\n    string hash,\r\n    string title,\r\n    address author\r\n  );\r\n\r\n    // ADDRESS BOOK MANAGEMENT\r\n\r\n    // Return this user's Address Book contract address\r\n    function fetchHashBox() public view returns (HashBoxBeta userData) {\r\n        userData = cidBox[msg.sender];\r\n        return userData;\r\n    }\r\n\r\n    // Create a new HashBoxBeta struct for this user\r\n    function createHashBox(string memory _boxName)\r\n        public\r\n        payable\r\n        returns (address contractAddress)\r\n    {\r\n        require(checkUserExists(msg.sender), \"Register username first!\");\r\n        HashBoxBeta newBox = new HashBoxBeta(msg.sender, _boxName);\r\n        cidBox[msg.sender] = newBox;\r\n        contractAddress = address(newBox);\r\n        emit HashBoxCreated(_boxName, msg.sender, contractAddress);\r\n        return contractAddress;\r\n    }\r\n\r\n    ///\r\n\r\n    function createAccount(string calldata name) external {\r\n        require(checkUserExists(msg.sender)==false, \"User already exists!\");\r\n        require(bytes(name).length>0, \"Username cannot be empty!\"); \r\n        userList[msg.sender].name = name;\r\n    }\r\n\r\n    // Returns the default name provided by an user\r\n    function getUsername(address pubkey) external view returns(string memory) {\r\n        require(checkUserExists(pubkey), \"User is not registered!\");\r\n        return userList[pubkey].name;\r\n    }\r\n\r\n     \r\n  \r\n    function checkUserExists(address pubkey) public view returns(bool) {\r\n        return bytes(userList[pubkey].name).length > 0;\r\n    }\r\n\r\n\r\n\r\n    function checkBalance() public view onlyOwner returns (uint256 amount) {\r\n        amount = address(this).balance;\r\n        return amount;\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        (bool sent, ) = msg.sender.call{value: checkBalance()}(\"\");\r\n        require(sent, \"There was a problem while withdrawing\");\r\n    }\r\n\r\n      function uploadIpfs(string memory _ipfsHash, string memory _title) public {\r\n        require(checkUserExists(msg.sender), \"Create an account first!\");\r\n        require(bytes(_ipfsHash).length > 0);\r\n        require(bytes(_title).length > 0);\r\n        require(msg.sender!=address(0));\r\n        ipfsCount ++;\r\n        _ipfs[ipfsCount] = Ipfs(ipfsCount, _ipfsHash, _title, msg.sender);\r\n        _uploadIpfs(msg.sender, _ipfsHash, _title);\r\n\r\n    // Trigger an event\r\n        emit IpfsUploaded(ipfsCount, _ipfsHash, _title, msg.sender);\r\n  }\r\n\r\n   \r\n\r\n\r\n     function _uploadIpfs(address me,string memory _ipfsHash, string memory _title) internal {\r\n        cid memory newCid = cid(_ipfsHash, _title);\r\n        userList[me].cidList.push(newCid);\r\n    }\r\n\r\n\r\n     function getMyCidList() external view returns(cid[] memory) {\r\n       require(checkUserExists(msg.sender), \"Create an account first!\");\r\n        return userList[msg.sender].cidList;\r\n\r\n    }\r\n\r\n\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
